package com.ngames.nclient.module.modules.exploit;

import java.util.ArrayList;
import java.util.List;

import com.ngames.nclient.NClient;
import com.ngames.nclient.baritone.BUtils;
import com.ngames.nclient.baritone.Baritone;
import com.ngames.nclient.baritone.SafeThread;
import com.ngames.nclient.event.Listener;
import com.ngames.nclient.event.NClientEvent;
import com.ngames.nclient.event.NClientEvent.RunTickKeyboardEvent;
import com.ngames.nclient.module.Category;
import com.ngames.nclient.module.Module;
import com.ngames.nclient.module.Modules;
import com.ngames.nclient.module.InHUDValue;
import com.ngames.nclient.module.ModuleType;
import com.ngames.nclient.module.settings.SettingValue;

import net.minecraft.block.BlockLever;
import net.minecraft.client.Minecraft;
import net.minecraft.client.settings.KeyBinding;
import net.minecraft.entity.Entity;
import net.minecraft.entity.item.EntityMinecartEmpty;
import net.minecraft.entity.passive.EntityDonkey;
import net.minecraft.entity.passive.EntityLlama;
import net.minecraft.entity.passive.EntityMule;
import net.minecraft.init.Blocks;
import net.minecraft.inventory.ClickType;
import net.minecraft.item.ItemStack;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.math.Vec3i;

@ModuleType(
        category = Category.EXPLOIT,
        description = "Automatically dupe items",
        name = "AutoDupe",
        words = "AutoDupe Dupe")
public class AutoDupe extends Module {

    private final SettingValue stealDelay = new SettingValue("StealDelay", 100, 0, 1000);
    private final SettingValue loadDonkeyAttemps = new SettingValue("loadDonkeyAttemps", 10, 1, 1000);
    private final SettingValue loadDonkeyClickDelay = new SettingValue("loadDonkeyClickDelay", 5000, 1000, 20000);

    private Vec3i startPos;
    private boolean waitF3;
    private final Minecraft MC = NClient.MC;
    private BlockPos lever1; //над поршнем
    private BlockPos lever2; // механизм   pls no russian comments, i don't speak it lol
    private BlockPos chest;
    private Entity lastMinecart;
    private Entity preLastMinecart;
    private boolean isStarted;

    public AutoDupe() {
        this.settings = Module.addSettings(this);
        this.inHud = new InHUDValue(0);
    }

    @Override
    public void onEnable() {
        super.onEnable();
        new Listener(RunTickKeyboardEvent.class, this);
        Vec3d v = MC.player.getPositionVector();
        startPos = new Vec3i(v.x, v.y, v.z);
        new Thread(() -> {
            start();
            isStarted = true;
        }).start();
        new SafeThread(() -> {
            if (!isStarted)
                BUtils.sleep(100);
            else
                cycle();
        },
                () -> {
                    while (MC.world == null)
                        BUtils.sleep(50);
                    BUtils.sleep(3000);
                    stop();
                    start();
                }, this).start();
    }

    @Override
    public void onInvoke(NClientEvent event) {
        if (this.waitF3) {
            Baritone.processKeyF3(30);
            this.waitF3 = false;
        }
    }

    private void start() {
        List<Entity> except = new ArrayList<>();
        int count = 0;
        Modules.packetCanceller.CPacketEntityAction.setValue(false);
        Modules.packetCanceller.CPacketInput.setValue(true);
        Modules.packetCanceller.CPacketPlayerAbilities.setValue(false);
        Modules.packetCanceller.CPacketPlayerDigging.setValue(true);
        Modules.packetCanceller.CPacketPlayerTryUseItem.setValue(false);
        Modules.packetCanceller.CPacketPlayerTryUseItemOnBlock.setValue(false);
        Modules.packetCanceller.CPacketPosition.setValue(true);
        Modules.packetCanceller.CPacketPositionRotation.setValue(true);
        Modules.packetCanceller.CPacketRotation.setValue(true);
        Modules.packetCanceller.CPacketUseEntity.setValue(false);
        Modules.packetCanceller.CPacketVehicleMove.setValue(true);
        if (!Modules.entityControl.isEnabled()) {
            Modules.entityControl.onToggle();
        }
        if (!Modules.packetCanceller.isEnabled()) {
            Modules.packetCanceller.onToggle();
        }
        Entity prevMinecart = null;
        while (count < 25 && this.enabled && MC.world != null) {
            Entity minecart = Baritone.findEntity(6, EntityMinecartEmpty.class, except);
            Entity prev = MC.player.getRidingEntity();
            if (minecart == null && this.enabled) {
                Baritone.displayMessage("There are no minecarts close to you!");
                while (minecart == null && MC.world != null) {
                    minecart = Baritone.findEntity(6, EntityMinecartEmpty.class, except);
                    BUtils.sleep(500);
                }
            }
            Baritone.setRotationToEntity(minecart, 0.3f);
            if (prev != null) {
                int to1 = 160;
                while (MC.player.getRidingEntity() == prev && MC.world != null && this.enabled) {
                    BUtils.sleep(50);
                    Baritone.interactWithEntity(minecart);
                    to1--;
                    if (to1 == 0) {
                        while (MC.player.getRidingEntity() != prevMinecart && MC.world != null && this.enabled) {
                            Baritone.interactWithEntity(prevMinecart);
                            BUtils.sleep(100);
                        }
                        while (MC.player.getRidingEntity() != prev && MC.world != null && this.enabled) {
                            Baritone.interactWithEntity(prev);
                            BUtils.sleep(100);
                        }
                        to1 = 160;
                    }
                }
            } else {
                while (MC.player.getRidingEntity() == null && MC.world != null) {
                    BUtils.sleep(50);
                    Baritone.interactWithEntity(minecart);
                }
            }
            if (count == 14) {
                this.waitF3 = true;
                while (waitF3 && MC.world != null)
                    BUtils.sleep(50);
            }
            if (count == 23)
                this.preLastMinecart = minecart;
            if (count == 24)
                lastMinecart = minecart;
            except.add(minecart);
            prevMinecart = prev;
            count++;
            BUtils.sleep(50);
        }
        Entity donkey = Baritone.findEntity(6, EntityDonkey.class);
        if (donkey == null) {
            donkey = Baritone.findEntity(6, EntityLlama.class);
        }
        if (donkey == null) {
            donkey = Baritone.findEntity(6, EntityMule.class);
        }

        int to = 80;
        while (MC.player.getRidingEntity() != donkey && MC.world != null) {
            Baritone.setRotationToEntity(donkey, 0.1f);
            BUtils.sleep(50);
            Baritone.interactWithEntity(donkey);
            to--;
            if (to == 0) {
                stop();
                start();
                return;
            }
        }
        getPos();
    }

    private void getPos() {
        List<BlockPos> blocks = Baritone.findBlocks(Blocks.LEVER);
        for (BlockPos block : blocks) {
            if (block.getX() == (int) preLastMinecart.posX || block.getZ() == (int) preLastMinecart.posZ) {
                lever2 = block;
            } else if (block.getX() == (int) lastMinecart.posX - 1 || block.getX() == (int) lastMinecart.posX + 1) {
                lever1 = block;
            }
        }
        this.chest = new BlockPos(lever1.getX(), lever1.getY() - 2, lever1.getZ());
    }

    private void stop() {
        stop1();
        stop2();
    }

    private void stop1() {
        if (Modules.entityControl.isEnabled())
            Modules.entityControl.onToggle();
        if (Modules.packetCanceller.isEnabled())
            Modules.packetCanceller.onToggle();
        int to2 = 100;
        while (MC.player.getRidingEntity() != null && MC.world != null && this.enabled) {
            KeyBinding.setKeyBindState(MC.gameSettings.keyBindSneak.getKeyCode(), true);
            BUtils.sleep(50);
            to2--;
            if (to2 == 0) {
                KeyBinding.setKeyBindState(MC.gameSettings.keyBindSneak.getKeyCode(), false);
                BUtils.sleep(50);
                Baritone.setRotationToBlockPos(lever1);
                BUtils.sleep(100);
                Baritone.rightClickBlock(lever1, EnumHand.MAIN_HAND);
                for (Entity e : MC.world.getLoadedEntityList()) {
                    if (e instanceof EntityDonkey && e != MC.player.getRidingEntity()) {
                        Baritone.setRotationToEntity(e);
                        Baritone.interactWithEntity(e);
                    }
                }
                BUtils.sleep(2000);
                Baritone.setRotationToBlockPos(lever1);
                BUtils.sleep(100);
                Baritone.rightClickBlock(lever1, EnumHand.MAIN_HAND);
                to2 = 100;
            }
        }
        KeyBinding.setKeyBindState(MC.gameSettings.keyBindSneak.getKeyCode(), false);
    }

    private void stop2() {
        if (!Modules.timer.isEnabled()) {
            Modules.timer.onToggle();
        }
        MC.player.sendChatMessage("#goto " + startPos.getX() + " " + startPos.getY() + " " + startPos.getZ());
        BUtils.sleep(3000);
        while (((int) MC.player.posX) != this.startPos.getX() && ((int) MC.player.posY) != this.startPos.getY()
                && ((int) MC.player.posZ) != ((int) MC.player.posZ) && this.enabled && MC.world != null) {
            BUtils.sleep(2000);
            MC.player.sendChatMessage("#goto " + startPos.getX() + " " + startPos.getY() + " " + startPos.getZ());
        }
        BUtils.sleep(2000);
        if (Modules.timer.isEnabled()) {
            Modules.timer.onToggle();
        }
    }

    private void lootDonkey() {
        for (int i = 1; i <= 16; i++) {
            BUtils.sleep((int) this.stealDelay.getValue());
            MC.playerController.windowClick(MC.player.openContainer.windowId, i, 0, ClickType.QUICK_MOVE, MC.player);
            if (!this.enabled) {
                break;
            }
        }
    }

    private void fillChest() {
        while (MC.player.openContainer.inventorySlots.size() < 54 && this.enabled && MC.world != null)
            BUtils.sleep(50);
        for (int i = 54; i <= 89; i++) {
            if (MC.player.openContainer.inventorySlots.get(i).getHasStack()) {
                BUtils.sleep((int) this.stealDelay.getValue());
                MC.playerController.windowClick(MC.player.openContainer.windowId, i, 0, ClickType.QUICK_MOVE, MC.player);
                this.inHud.set(((int) this.inHud.get()) + 1);
            }
            if (!this.enabled) {
                break;
            }
        }
    }

    private void fillDonkey() {
        for (int i = 17; i <= 52; i++) {
            boolean isFull = true;
            for (int k = 2; k <= 16; k++) {
                if (!MC.player.openContainer.inventorySlots.get(k).getHasStack())
                    isFull = false;
            }
            if (isFull) {
                return;
            }
            if (MC.player.openContainer.inventorySlots.get(i).getHasStack()) {
                BUtils.sleep((int) this.stealDelay.getValue());
                MC.playerController.windowClick(MC.player.openContainer.windowId, i, 0, ClickType.QUICK_MOVE, MC.player);
            }
            if (!this.enabled) {
                return;
            }
        }
    }

    private void openInv() {
        MC.player.sendHorseInventory();
        int to = 200;
        while (MC.inGameHasFocus) {
            BUtils.sleep(50);
            to--;
            if (to == 0) {
                int to2 = 50;
                while (MC.player.getRidingEntity() != lastMinecart) {
                    Baritone.setRotationToEntity(lastMinecart);
                    Baritone.interactWithEntity(lastMinecart);
                    BUtils.sleep(100);
                    to2--;
                    if (to2 == 0) {
                        toggleLever1(false);
                        toggleLever2(false);
                        stop();
                        start();
                        return;
                    }
                }
                MC.player.sendHorseInventory();
                int to3 = 100;
                while (MC.inGameHasFocus) {
                    BUtils.sleep(50);
                    to3--;
                    if (to3 == 0) {
                        toggleLever1(false);
                        toggleLever2(false);
                        stop();
                        start();
                        return;
                    }
                }
            }
        }
    }

    private void cycle() {
        if (this.lever1 == null || this.lever2 == null || this.chest == null) {
            getPos();
            if (this.lever1 == null) {
                Baritone.displayMessage("failed find: lever1");
            }
            if (this.chest == null) {
                Baritone.displayMessage("failed find: chest");
            }
            if (this.lever2 == null) {
                Baritone.displayMessage("failed find: lever2");
            }
        }
        toggleLever1(true);
        BUtils.sleep((int) this.loadDonkeyClickDelay.getValue());
        toggleLever2(true);
        BUtils.sleep(1000);
        Entity donkey = null;
        int to1 = (int) this.loadDonkeyAttemps.getValue();
        while (!(donkey instanceof EntityDonkey)) {
            boolean currentState = MC.world.getBlockState(lever1).equals(MC.world.getBlockState(lever1).withProperty(BlockLever.POWERED, true));
            toggleLever1(!currentState);
            if (currentState)
                BUtils.sleep(1000);
            else
                BUtils.sleep((int) this.loadDonkeyClickDelay.getValue());
            Baritone.setRotationToBlockPos(chest);
            BUtils.sleep(100);
            donkey = NClient.MC.objectMouseOver.entityHit;
            to1--;
            if (to1 == 0) {
                this.isStarted = false;
                toggleLever2(false);
                toggleLever1(false);
                stop();
                start();
                this.isStarted = true;
                return;
            }
        }
        openInv();
        lootDonkey();
        MC.player.closeScreen();
        toggleLever2(false);
        Baritone.interactWithEntity(donkey);
        BUtils.sleep(2000);
        openInv();
        fillDonkey();
        MC.player.closeScreen();
        int empties = 0;
        for (ItemStack item : MC.player.inventory.mainInventory) {
            if (Baritone.isEmpty(item))
                empties++;
        }
        if (empties < 15) {
            while (MC.inGameHasFocus) {
                Baritone.setRotationToBlockPos(chest);
                Baritone.rightClickBlock(chest, EnumHand.MAIN_HAND);
                BUtils.sleep(500);
            }
            fillChest();
            MC.player.closeScreen();
        }
        if ((int) (Modules.packetCanceller.inHud.get()) >= 27000) {
            stop();
            start();
        }
    }

    private void toggleLever1(boolean state) {
        int to2 = 40;
        while (!MC.world.getBlockState(lever1).equals(MC.world.getBlockState(lever1).withProperty(BlockLever.POWERED, state)) && MC.world != null && this.enabled) {
            BUtils.sleep(50);
            to2--;
            if (to2 == 0) {
                Baritone.setRotationToBlockPos(lever1);
                BUtils.sleep(100);
                Baritone.rightClickBlock(lever1, EnumHand.MAIN_HAND);
                to2 = 40;
            }
        }
    }

    private void toggleLever2(boolean state) {
        int to2 = 40;
        while (!MC.world.getBlockState(lever2).equals(MC.world.getBlockState(lever2).withProperty(BlockLever.POWERED, state)) && MC.world != null && this.enabled) {
            BUtils.sleep(50);
            to2--;
            if (to2 == 0) {
                Baritone.setRotationToBlockPos(lever2);
                BUtils.sleep(100);
                Baritone.rightClickBlock(lever2, EnumHand.MAIN_HAND);
                to2 = 40;
            }
        }
    }
}
